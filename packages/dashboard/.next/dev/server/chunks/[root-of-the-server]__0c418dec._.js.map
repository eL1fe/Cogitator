{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/lib/db/index.ts"],"sourcesContent":["import { Pool, PoolClient } from 'pg';\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    pool = new Pool({\n      host: process.env.POSTGRES_HOST || 'localhost',\n      port: parseInt(process.env.POSTGRES_PORT || '5432'),\n      user: process.env.POSTGRES_USER || 'cogitator',\n      password: process.env.POSTGRES_PASSWORD || 'cogitator',\n      database: process.env.POSTGRES_DB || 'cogitator',\n      max: 20,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: 2000,\n    });\n  }\n  return pool;\n}\n\nexport async function query<T>(sql: string, params?: unknown[]): Promise<T[]> {\n  const pool = getPool();\n  const result = await pool.query(sql, params);\n  return result.rows as T[];\n}\n\nexport async function queryOne<T>(sql: string, params?: unknown[]): Promise<T | null> {\n  const rows = await query<T>(sql, params);\n  return rows[0] || null;\n}\n\nexport async function execute(sql: string, params?: unknown[]): Promise<number> {\n  const pool = getPool();\n  const result = await pool.query(sql, params);\n  return result.rowCount || 0;\n}\n\nexport async function withTransaction<T>(fn: (client: PoolClient) => Promise<T>): Promise<T> {\n  const pool = getPool();\n  const client = await pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n    const result = await fn(client);\n    await client.query('COMMIT');\n    return result;\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}\n\nexport async function initializeSchema(): Promise<void> {\n  const pool = getPool();\n  \n  await pool.query(`\n    -- Agents table\n    CREATE TABLE IF NOT EXISTS dashboard_agents (\n      id TEXT PRIMARY KEY,\n      name TEXT NOT NULL,\n      model TEXT NOT NULL,\n      description TEXT,\n      instructions TEXT,\n      status TEXT DEFAULT 'offline' CHECK (status IN ('online', 'offline', 'busy')),\n      total_runs INTEGER DEFAULT 0,\n      total_tokens BIGINT DEFAULT 0,\n      total_cost DECIMAL(12, 6) DEFAULT 0,\n      last_run_at TIMESTAMPTZ,\n      created_at TIMESTAMPTZ DEFAULT NOW(),\n      updated_at TIMESTAMPTZ DEFAULT NOW()\n    );\n\n    -- Runs table\n    CREATE TABLE IF NOT EXISTS dashboard_runs (\n      id TEXT PRIMARY KEY,\n      agent_id TEXT NOT NULL REFERENCES dashboard_agents(id) ON DELETE CASCADE,\n      thread_id TEXT,\n      status TEXT DEFAULT 'running' CHECK (status IN ('running', 'completed', 'failed', 'cancelled')),\n      input TEXT NOT NULL,\n      output TEXT,\n      started_at TIMESTAMPTZ DEFAULT NOW(),\n      completed_at TIMESTAMPTZ,\n      duration INTEGER,\n      input_tokens INTEGER DEFAULT 0,\n      output_tokens INTEGER DEFAULT 0,\n      total_tokens INTEGER DEFAULT 0,\n      cost DECIMAL(12, 6) DEFAULT 0,\n      error TEXT\n    );\n\n    -- Tool calls table\n    CREATE TABLE IF NOT EXISTS dashboard_tool_calls (\n      id TEXT PRIMARY KEY,\n      run_id TEXT NOT NULL REFERENCES dashboard_runs(id) ON DELETE CASCADE,\n      name TEXT NOT NULL,\n      arguments JSONB,\n      result JSONB,\n      status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'success', 'error')),\n      duration INTEGER,\n      started_at TIMESTAMPTZ DEFAULT NOW(),\n      completed_at TIMESTAMPTZ,\n      error TEXT\n    );\n\n    -- Spans table (for tracing)\n    CREATE TABLE IF NOT EXISTS dashboard_spans (\n      id TEXT PRIMARY KEY,\n      run_id TEXT NOT NULL REFERENCES dashboard_runs(id) ON DELETE CASCADE,\n      trace_id TEXT NOT NULL,\n      parent_id TEXT,\n      name TEXT NOT NULL,\n      kind TEXT DEFAULT 'internal',\n      status TEXT DEFAULT 'unset' CHECK (status IN ('ok', 'error', 'unset')),\n      start_time BIGINT NOT NULL,\n      end_time BIGINT,\n      duration INTEGER,\n      attributes JSONB,\n      events JSONB\n    );\n\n    -- Logs table\n    CREATE TABLE IF NOT EXISTS dashboard_logs (\n      id TEXT PRIMARY KEY,\n      timestamp TIMESTAMPTZ DEFAULT NOW(),\n      level TEXT NOT NULL CHECK (level IN ('debug', 'info', 'warn', 'error')),\n      message TEXT NOT NULL,\n      source TEXT,\n      agent_id TEXT,\n      run_id TEXT,\n      metadata JSONB\n    );\n\n    -- Messages table (conversation history)\n    CREATE TABLE IF NOT EXISTS dashboard_messages (\n      id TEXT PRIMARY KEY,\n      run_id TEXT NOT NULL REFERENCES dashboard_runs(id) ON DELETE CASCADE,\n      role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system', 'tool')),\n      content TEXT NOT NULL,\n      tool_call_id TEXT,\n      created_at TIMESTAMPTZ DEFAULT NOW()\n    );\n\n    -- Config table (key-value store)\n    CREATE TABLE IF NOT EXISTS dashboard_config (\n      key TEXT PRIMARY KEY,\n      value JSONB NOT NULL,\n      updated_at TIMESTAMPTZ DEFAULT NOW()\n    );\n\n    -- Indexes\n    CREATE INDEX IF NOT EXISTS idx_dashboard_runs_agent_id ON dashboard_runs(agent_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_runs_status ON dashboard_runs(status);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_runs_started_at ON dashboard_runs(started_at DESC);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_tool_calls_run_id ON dashboard_tool_calls(run_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_spans_run_id ON dashboard_spans(run_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_spans_trace_id ON dashboard_spans(trace_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_logs_timestamp ON dashboard_logs(timestamp DESC);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_logs_level ON dashboard_logs(level);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_logs_run_id ON dashboard_logs(run_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_messages_run_id ON dashboard_messages(run_id);\n  `);\n}\n\nexport async function closePool(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAEA,IAAI,OAAoB;AAEjB,SAAS;IACd,IAAI,CAAC,MAAM;QACT,OAAO,IAAI,qMAAI,CAAC;YACd,MAAM,QAAQ,GAAG,CAAC,aAAa,IAAI;YACnC,MAAM,SAAS,QAAQ,GAAG,CAAC,aAAa,IAAI;YAC5C,MAAM,QAAQ,GAAG,CAAC,aAAa,IAAI;YACnC,UAAU,QAAQ,GAAG,CAAC,iBAAiB,IAAI;YAC3C,UAAU,QAAQ,GAAG,CAAC,WAAW,IAAI;YACrC,KAAK;YACL,mBAAmB;YACnB,yBAAyB;QAC3B;IACF;IACA,OAAO;AACT;AAEO,eAAe,MAAS,GAAW,EAAE,MAAkB;IAC5D,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,KAAK,CAAC,KAAK;IACrC,OAAO,OAAO,IAAI;AACpB;AAEO,eAAe,SAAY,GAAW,EAAE,MAAkB;IAC/D,MAAM,OAAO,MAAM,MAAS,KAAK;IACjC,OAAO,IAAI,CAAC,EAAE,IAAI;AACpB;AAEO,eAAe,QAAQ,GAAW,EAAE,MAAkB;IAC3D,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,KAAK,CAAC,KAAK;IACrC,OAAO,OAAO,QAAQ,IAAI;AAC5B;AAEO,eAAe,gBAAmB,EAAsC;IAC7E,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,OAAO;IAEjC,IAAI;QACF,MAAM,OAAO,KAAK,CAAC;QACnB,MAAM,SAAS,MAAM,GAAG;QACxB,MAAM,OAAO,KAAK,CAAC;QACnB,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,OAAO,KAAK,CAAC;QACnB,MAAM;IACR,SAAU;QACR,OAAO,OAAO;IAChB;AACF;AAEO,eAAe;IACpB,MAAM,OAAO;IAEb,MAAM,KAAK,KAAK,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyGlB,CAAC;AACH;AAEO,eAAe;IACpB,IAAI,MAAM;QACR,MAAM,KAAK,GAAG;QACd,OAAO;IACT;AACF"}},
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/lib/db/runs.ts"],"sourcesContent":["import { query, queryOne, execute, withTransaction } from './index';\nimport { nanoid } from 'nanoid';\nimport type { Run, ToolCall, Message } from '@/types';\n\ninterface RunRow {\n  id: string;\n  agent_id: string;\n  thread_id: string | null;\n  status: 'running' | 'completed' | 'failed' | 'cancelled';\n  input: string;\n  output: string | null;\n  started_at: Date;\n  completed_at: Date | null;\n  duration: number | null;\n  input_tokens: number;\n  output_tokens: number;\n  total_tokens: number;\n  cost: string;\n  error: string | null;\n  agent_name?: string;\n  agent_model?: string;\n}\n\ninterface ToolCallRow {\n  id: string;\n  run_id: string;\n  name: string;\n  arguments: Record<string, unknown> | null;\n  result: unknown;\n  status: 'pending' | 'success' | 'error';\n  duration: number | null;\n  started_at: Date;\n  completed_at: Date | null;\n  error: string | null;\n}\n\ninterface MessageRow {\n  id: string;\n  run_id: string;\n  role: 'user' | 'assistant' | 'system' | 'tool';\n  content: string;\n  tool_call_id: string | null;\n  created_at: Date;\n}\n\nfunction rowToRun(row: RunRow): Run {\n  return {\n    id: row.id,\n    agentId: row.agent_id,\n    agentName: row.agent_name,\n    model: row.agent_model,\n    status: row.status,\n    input: row.input,\n    output: row.output || undefined,\n    startedAt: row.started_at.toISOString(),\n    completedAt: row.completed_at?.toISOString(),\n    duration: row.duration || undefined,\n    inputTokens: row.input_tokens,\n    outputTokens: row.output_tokens,\n    totalTokens: row.total_tokens,\n    cost: parseFloat(row.cost) || 0,\n    error: row.error || undefined,\n  };\n}\n\nfunction rowToToolCall(row: ToolCallRow): ToolCall {\n  return {\n    id: row.id,\n    name: row.name,\n    arguments: row.arguments || {},\n    result: row.result,\n    status: row.status,\n    duration: row.duration || undefined,\n    error: row.error || undefined,\n  };\n}\n\nfunction rowToMessage(row: MessageRow): Message {\n  return {\n    id: row.id,\n    role: row.role,\n    content: row.content,\n    toolCallId: row.tool_call_id || undefined,\n    createdAt: row.created_at.toISOString(),\n  };\n}\n\nexport async function getAllRuns(options?: {\n  limit?: number;\n  offset?: number;\n  status?: string;\n  agentId?: string;\n}): Promise<Run[]> {\n  let sql = `\n    SELECT r.*, a.name as agent_name, a.model as agent_model\n    FROM dashboard_runs r\n    LEFT JOIN dashboard_agents a ON r.agent_id = a.id\n    WHERE 1=1\n  `;\n  const params: unknown[] = [];\n  let paramIndex = 1;\n\n  if (options?.status) {\n    sql += ` AND r.status = $${paramIndex++}`;\n    params.push(options.status);\n  }\n  if (options?.agentId) {\n    sql += ` AND r.agent_id = $${paramIndex++}`;\n    params.push(options.agentId);\n  }\n\n  sql += ' ORDER BY r.started_at DESC';\n\n  if (options?.limit) {\n    sql += ` LIMIT $${paramIndex++}`;\n    params.push(options.limit);\n  }\n  if (options?.offset) {\n    sql += ` OFFSET $${paramIndex++}`;\n    params.push(options.offset);\n  }\n\n  const rows = await query<RunRow>(sql, params);\n  return rows.map(rowToRun);\n}\n\nexport async function getRunById(id: string): Promise<Run | null> {\n  const row = await queryOne<RunRow>(\n    `SELECT r.*, a.name as agent_name, a.model as agent_model\n     FROM dashboard_runs r\n     LEFT JOIN dashboard_agents a ON r.agent_id = a.id\n     WHERE r.id = $1`,\n    [id]\n  );\n  return row ? rowToRun(row) : null;\n}\n\nexport async function getRunToolCalls(runId: string): Promise<ToolCall[]> {\n  const rows = await query<ToolCallRow>(\n    'SELECT * FROM dashboard_tool_calls WHERE run_id = $1 ORDER BY started_at',\n    [runId]\n  );\n  return rows.map(rowToToolCall);\n}\n\nexport async function getRunMessages(runId: string): Promise<Message[]> {\n  const rows = await query<MessageRow>(\n    'SELECT * FROM dashboard_messages WHERE run_id = $1 ORDER BY created_at',\n    [runId]\n  );\n  return rows.map(rowToMessage);\n}\n\nexport async function createRun(data: {\n  agentId: string;\n  threadId?: string;\n  input: string;\n}): Promise<Run> {\n  const id = `run_${nanoid(12)}`;\n  \n  await execute(\n    `INSERT INTO dashboard_runs (id, agent_id, thread_id, input, status)\n     VALUES ($1, $2, $3, $4, 'running')`,\n    [id, data.agentId, data.threadId || null, data.input]\n  );\n\n  const run = await getRunById(id);\n  return run!;\n}\n\nexport async function updateRun(id: string, data: Partial<{\n  status: 'running' | 'completed' | 'failed' | 'cancelled';\n  output: string;\n  duration: number;\n  inputTokens: number;\n  outputTokens: number;\n  totalTokens: number;\n  cost: number;\n  error: string;\n}>): Promise<Run | null> {\n  const updates: string[] = [];\n  const values: unknown[] = [];\n  let paramIndex = 1;\n\n  if (data.status !== undefined) {\n    updates.push(`status = $${paramIndex++}`);\n    values.push(data.status);\n    if (data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled') {\n      updates.push(`completed_at = NOW()`);\n    }\n  }\n  if (data.output !== undefined) {\n    updates.push(`output = $${paramIndex++}`);\n    values.push(data.output);\n  }\n  if (data.duration !== undefined) {\n    updates.push(`duration = $${paramIndex++}`);\n    values.push(data.duration);\n  }\n  if (data.inputTokens !== undefined) {\n    updates.push(`input_tokens = $${paramIndex++}`);\n    values.push(data.inputTokens);\n  }\n  if (data.outputTokens !== undefined) {\n    updates.push(`output_tokens = $${paramIndex++}`);\n    values.push(data.outputTokens);\n  }\n  if (data.totalTokens !== undefined) {\n    updates.push(`total_tokens = $${paramIndex++}`);\n    values.push(data.totalTokens);\n  }\n  if (data.cost !== undefined) {\n    updates.push(`cost = $${paramIndex++}`);\n    values.push(data.cost);\n  }\n  if (data.error !== undefined) {\n    updates.push(`error = $${paramIndex++}`);\n    values.push(data.error);\n  }\n\n  if (updates.length === 0) return getRunById(id);\n\n  values.push(id);\n  await execute(\n    `UPDATE dashboard_runs SET ${updates.join(', ')} WHERE id = $${paramIndex}`,\n    values\n  );\n\n  return getRunById(id);\n}\n\nexport async function addToolCall(data: {\n  runId: string;\n  name: string;\n  arguments?: Record<string, unknown>;\n}): Promise<string> {\n  const id = `tc_${nanoid(12)}`;\n  \n  await execute(\n    `INSERT INTO dashboard_tool_calls (id, run_id, name, arguments)\n     VALUES ($1, $2, $3, $4)`,\n    [id, data.runId, data.name, JSON.stringify(data.arguments || {})]\n  );\n\n  return id;\n}\n\nexport async function updateToolCall(id: string, data: {\n  status: 'success' | 'error';\n  result?: unknown;\n  duration?: number;\n  error?: string;\n}): Promise<void> {\n  await execute(\n    `UPDATE dashboard_tool_calls \n     SET status = $1, result = $2, duration = $3, error = $4, completed_at = NOW()\n     WHERE id = $5`,\n    [data.status, JSON.stringify(data.result), data.duration || null, data.error || null, id]\n  );\n}\n\nexport async function addMessage(data: {\n  runId: string;\n  role: 'user' | 'assistant' | 'system' | 'tool';\n  content: string;\n  toolCallId?: string;\n}): Promise<string> {\n  const id = `msg_${nanoid(12)}`;\n  \n  await execute(\n    `INSERT INTO dashboard_messages (id, run_id, role, content, tool_call_id)\n     VALUES ($1, $2, $3, $4, $5)`,\n    [id, data.runId, data.role, data.content, data.toolCallId || null]\n  );\n\n  return id;\n}\n\nexport async function getRunCount(status?: string): Promise<number> {\n  let sql = 'SELECT COUNT(*) as count FROM dashboard_runs';\n  const params: unknown[] = [];\n  \n  if (status) {\n    sql += ' WHERE status = $1';\n    params.push(status);\n  }\n\n  const result = await queryOne<{ count: string }>(sql, params);\n  return parseInt(result?.count || '0');\n}\n\nexport async function getRecentRuns(limit = 10): Promise<Run[]> {\n  return getAllRuns({ limit });\n}\n\nexport async function getRunningRuns(): Promise<Run[]> {\n  return getAllRuns({ status: 'running' });\n}\n\nexport async function getRunStats(period: 'day' | 'week' | 'month' = 'day'): Promise<{\n  totalRuns: number;\n  completedRuns: number;\n  failedRuns: number;\n  totalTokens: number;\n  totalCost: number;\n}> {\n  const intervals = {\n    day: \"NOW() - INTERVAL '1 day'\",\n    week: \"NOW() - INTERVAL '7 days'\",\n    month: \"NOW() - INTERVAL '30 days'\",\n  };\n\n  const result = await queryOne<{\n    total_runs: string;\n    completed_runs: string;\n    failed_runs: string;\n    total_tokens: string;\n    total_cost: string;\n  }>(`\n    SELECT \n      COUNT(*) as total_runs,\n      SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed_runs,\n      SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed_runs,\n      COALESCE(SUM(total_tokens), 0) as total_tokens,\n      COALESCE(SUM(cost), 0) as total_cost\n    FROM dashboard_runs\n    WHERE started_at >= ${intervals[period]}\n  `);\n\n  return {\n    totalRuns: parseInt(result?.total_runs || '0'),\n    completedRuns: parseInt(result?.completed_runs || '0'),\n    failedRuns: parseInt(result?.failed_runs || '0'),\n    totalTokens: parseInt(result?.total_tokens || '0'),\n    totalCost: parseFloat(result?.total_cost || '0'),\n  };\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 597, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/lib/redis.ts"],"sourcesContent":["import Redis from 'ioredis';\n\nlet redis: Redis | null = null;\nlet subscriber: Redis | null = null;\n\nexport function getRedis(): Redis {\n  if (!redis) {\n    redis = new Redis({\n      host: process.env.REDIS_HOST || 'localhost',\n      port: parseInt(process.env.REDIS_PORT || '6379'),\n      maxRetriesPerRequest: 3,\n      lazyConnect: true,\n    });\n  }\n  return redis;\n}\n\nexport function getSubscriber(): Redis {\n  if (!subscriber) {\n    subscriber = new Redis({\n      host: process.env.REDIS_HOST || 'localhost',\n      port: parseInt(process.env.REDIS_PORT || '6379'),\n      maxRetriesPerRequest: 3,\n      lazyConnect: true,\n    });\n  }\n  return subscriber;\n}\n\nexport async function publish(channel: string, message: unknown): Promise<void> {\n  const client = getRedis();\n  await client.publish(channel, JSON.stringify(message));\n}\n\nexport async function subscribe(\n  channel: string,\n  callback: (message: unknown) => void\n): Promise<() => void> {\n  const sub = getSubscriber();\n  \n  await sub.subscribe(channel);\n  \n  const handler = (ch: string, msg: string) => {\n    if (ch === channel) {\n      try {\n        callback(JSON.parse(msg));\n      } catch {\n        callback(msg);\n      }\n    }\n  };\n  \n  sub.on('message', handler);\n  \n  return () => {\n    sub.off('message', handler);\n    sub.unsubscribe(channel);\n  };\n}\n\nexport async function cache<T>(\n  key: string,\n  fn: () => Promise<T>,\n  ttlSeconds = 60\n): Promise<T> {\n  const client = getRedis();\n  \n  const cached = await client.get(key);\n  if (cached) {\n    return JSON.parse(cached) as T;\n  }\n  \n  const result = await fn();\n  await client.setex(key, ttlSeconds, JSON.stringify(result));\n  \n  return result;\n}\n\nexport async function invalidateCache(pattern: string): Promise<void> {\n  const client = getRedis();\n  const keys = await client.keys(pattern);\n  if (keys.length > 0) {\n    await client.del(...keys);\n  }\n}\n\nexport async function closeRedis(): Promise<void> {\n  if (redis) {\n    await redis.quit();\n    redis = null;\n  }\n  if (subscriber) {\n    await subscriber.quit();\n    subscriber = null;\n  }\n}\n\n// Real-time channels\nexport const CHANNELS = {\n  RUN_STARTED: 'cogitator:run:started',\n  RUN_COMPLETED: 'cogitator:run:completed',\n  RUN_FAILED: 'cogitator:run:failed',\n  LOG_ENTRY: 'cogitator:log:entry',\n  AGENT_STATUS: 'cogitator:agent:status',\n  TOOL_CALL: 'cogitator:tool:call',\n} as const;\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;AAEA,IAAI,QAAsB;AAC1B,IAAI,aAA2B;AAExB,SAAS;IACd,IAAI,CAAC,OAAO;QACV,QAAQ,IAAI,0MAAK,CAAC;YAChB,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;YAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;YACzC,sBAAsB;YACtB,aAAa;QACf;IACF;IACA,OAAO;AACT;AAEO,SAAS;IACd,IAAI,CAAC,YAAY;QACf,aAAa,IAAI,0MAAK,CAAC;YACrB,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;YAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;YACzC,sBAAsB;YACtB,aAAa;QACf;IACF;IACA,OAAO;AACT;AAEO,eAAe,QAAQ,OAAe,EAAE,OAAgB;IAC7D,MAAM,SAAS;IACf,MAAM,OAAO,OAAO,CAAC,SAAS,KAAK,SAAS,CAAC;AAC/C;AAEO,eAAe,UACpB,OAAe,EACf,QAAoC;IAEpC,MAAM,MAAM;IAEZ,MAAM,IAAI,SAAS,CAAC;IAEpB,MAAM,UAAU,CAAC,IAAY;QAC3B,IAAI,OAAO,SAAS;YAClB,IAAI;gBACF,SAAS,KAAK,KAAK,CAAC;YACtB,EAAE,OAAM;gBACN,SAAS;YACX;QACF;IACF;IAEA,IAAI,EAAE,CAAC,WAAW;IAElB,OAAO;QACL,IAAI,GAAG,CAAC,WAAW;QACnB,IAAI,WAAW,CAAC;IAClB;AACF;AAEO,eAAe,MACpB,GAAW,EACX,EAAoB,EACpB,aAAa,EAAE;IAEf,MAAM,SAAS;IAEf,MAAM,SAAS,MAAM,OAAO,GAAG,CAAC;IAChC,IAAI,QAAQ;QACV,OAAO,KAAK,KAAK,CAAC;IACpB;IAEA,MAAM,SAAS,MAAM;IACrB,MAAM,OAAO,KAAK,CAAC,KAAK,YAAY,KAAK,SAAS,CAAC;IAEnD,OAAO;AACT;AAEO,eAAe,gBAAgB,OAAe;IACnD,MAAM,SAAS;IACf,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC;IAC/B,IAAI,KAAK,MAAM,GAAG,GAAG;QACnB,MAAM,OAAO,GAAG,IAAI;IACtB;AACF;AAEO,eAAe;IACpB,IAAI,OAAO;QACT,MAAM,MAAM,IAAI;QAChB,QAAQ;IACV;IACA,IAAI,YAAY;QACd,MAAM,WAAW,IAAI;QACrB,aAAa;IACf;AACF;AAGO,MAAM,WAAW;IACtB,aAAa;IACb,eAAe;IACf,YAAY;IACZ,WAAW;IACX,cAAc;IACd,WAAW;AACb"}},
    {"offset": {"line": 704, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/app/api/runs/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getAllRuns, createRun, getRunStats } from '@/lib/db/runs';\nimport { initializeSchema } from '@/lib/db';\nimport { publish, CHANNELS } from '@/lib/redis';\n\nlet initialized = false;\n\nasync function ensureInitialized() {\n  if (!initialized) {\n    try {\n      await initializeSchema();\n      initialized = true;\n    } catch (error) {\n      console.error('Failed to initialize database:', error);\n    }\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    await ensureInitialized();\n    \n    const searchParams = request.nextUrl.searchParams;\n    const status = searchParams.get('status') || undefined;\n    const agentId = searchParams.get('agentId') || undefined;\n    const limit = parseInt(searchParams.get('limit') || '50');\n    const offset = parseInt(searchParams.get('offset') || '0');\n\n    const runs = await getAllRuns({ status, agentId, limit, offset });\n    const stats = await getRunStats('day');\n\n    return NextResponse.json({\n      runs,\n      stats,\n      pagination: { limit, offset },\n    });\n  } catch (error) {\n    console.error('Failed to fetch runs:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch runs' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    await ensureInitialized();\n    const body = await request.json();\n    \n    if (!body.agentId || !body.input) {\n      return NextResponse.json(\n        { error: 'agentId and input are required' },\n        { status: 400 }\n      );\n    }\n\n    const run = await createRun({\n      agentId: body.agentId,\n      threadId: body.threadId,\n      input: body.input,\n    });\n\n    // Publish real-time event\n    try {\n      await publish(CHANNELS.RUN_STARTED, run);\n    } catch {\n      // Redis might not be available\n    }\n\n    return NextResponse.json(run, { status: 201 });\n  } catch (error) {\n    console.error('Failed to create run:', error);\n    return NextResponse.json(\n      { error: 'Failed to create run' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;AAEA,IAAI,cAAc;AAElB,eAAe;IACb,IAAI,CAAC,aAAa;QAChB,IAAI;YACF,MAAM,IAAA,wKAAgB;YACtB,cAAc;QAChB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,kCAAkC;QAClD;IACF;AACF;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM;QAEN,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,SAAS,aAAa,GAAG,CAAC,aAAa;QAC7C,MAAM,UAAU,aAAa,GAAG,CAAC,cAAc;QAC/C,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY;QACpD,MAAM,SAAS,SAAS,aAAa,GAAG,CAAC,aAAa;QAEtD,MAAM,OAAO,MAAM,IAAA,iKAAU,EAAC;YAAE;YAAQ;YAAS;YAAO;QAAO;QAC/D,MAAM,QAAQ,MAAM,IAAA,kKAAW,EAAC;QAEhC,OAAO,qPAAY,CAAC,IAAI,CAAC;YACvB;YACA;YACA,YAAY;gBAAE;gBAAO;YAAO;QAC9B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,qPAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAuB,GAChC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM;QACN,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,IAAI,CAAC,KAAK,OAAO,IAAI,CAAC,KAAK,KAAK,EAAE;YAChC,OAAO,qPAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAiC,GAC1C;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,MAAM,MAAM,IAAA,gKAAS,EAAC;YAC1B,SAAS,KAAK,OAAO;YACrB,UAAU,KAAK,QAAQ;YACvB,OAAO,KAAK,KAAK;QACnB;QAEA,0BAA0B;QAC1B,IAAI;YACF,MAAM,IAAA,yJAAO,EAAC,0JAAQ,CAAC,WAAW,EAAE;QACtC,EAAE,OAAM;QACN,+BAA+B;QACjC;QAEA,OAAO,qPAAY,CAAC,IAAI,CAAC,KAAK;YAAE,QAAQ;QAAI;IAC9C,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,qPAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAuB,GAChC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}