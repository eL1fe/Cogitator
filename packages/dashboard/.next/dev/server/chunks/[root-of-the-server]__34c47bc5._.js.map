{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/lib/db/index.ts"],"sourcesContent":["import { Pool, PoolClient } from 'pg';\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    pool = new Pool({\n      host: process.env.POSTGRES_HOST || 'localhost',\n      port: parseInt(process.env.POSTGRES_PORT || '5432'),\n      user: process.env.POSTGRES_USER || 'cogitator',\n      password: process.env.POSTGRES_PASSWORD || 'cogitator',\n      database: process.env.POSTGRES_DB || 'cogitator',\n      max: 20,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: 2000,\n    });\n  }\n  return pool;\n}\n\nexport async function query<T>(sql: string, params?: unknown[]): Promise<T[]> {\n  const pool = getPool();\n  const result = await pool.query(sql, params);\n  return result.rows as T[];\n}\n\nexport async function queryOne<T>(sql: string, params?: unknown[]): Promise<T | null> {\n  const rows = await query<T>(sql, params);\n  return rows[0] || null;\n}\n\nexport async function execute(sql: string, params?: unknown[]): Promise<number> {\n  const pool = getPool();\n  const result = await pool.query(sql, params);\n  return result.rowCount || 0;\n}\n\nexport async function withTransaction<T>(fn: (client: PoolClient) => Promise<T>): Promise<T> {\n  const pool = getPool();\n  const client = await pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n    const result = await fn(client);\n    await client.query('COMMIT');\n    return result;\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}\n\nexport async function initializeSchema(): Promise<void> {\n  const pool = getPool();\n  \n  await pool.query(`\n    -- Agents table\n    CREATE TABLE IF NOT EXISTS dashboard_agents (\n      id TEXT PRIMARY KEY,\n      name TEXT NOT NULL,\n      model TEXT NOT NULL,\n      description TEXT,\n      instructions TEXT,\n      status TEXT DEFAULT 'offline' CHECK (status IN ('online', 'offline', 'busy')),\n      total_runs INTEGER DEFAULT 0,\n      total_tokens BIGINT DEFAULT 0,\n      total_cost DECIMAL(12, 6) DEFAULT 0,\n      last_run_at TIMESTAMPTZ,\n      created_at TIMESTAMPTZ DEFAULT NOW(),\n      updated_at TIMESTAMPTZ DEFAULT NOW()\n    );\n\n    -- Runs table\n    CREATE TABLE IF NOT EXISTS dashboard_runs (\n      id TEXT PRIMARY KEY,\n      agent_id TEXT NOT NULL REFERENCES dashboard_agents(id) ON DELETE CASCADE,\n      thread_id TEXT,\n      status TEXT DEFAULT 'running' CHECK (status IN ('running', 'completed', 'failed', 'cancelled')),\n      input TEXT NOT NULL,\n      output TEXT,\n      started_at TIMESTAMPTZ DEFAULT NOW(),\n      completed_at TIMESTAMPTZ,\n      duration INTEGER,\n      input_tokens INTEGER DEFAULT 0,\n      output_tokens INTEGER DEFAULT 0,\n      total_tokens INTEGER DEFAULT 0,\n      cost DECIMAL(12, 6) DEFAULT 0,\n      error TEXT\n    );\n\n    -- Tool calls table\n    CREATE TABLE IF NOT EXISTS dashboard_tool_calls (\n      id TEXT PRIMARY KEY,\n      run_id TEXT NOT NULL REFERENCES dashboard_runs(id) ON DELETE CASCADE,\n      name TEXT NOT NULL,\n      arguments JSONB,\n      result JSONB,\n      status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'success', 'error')),\n      duration INTEGER,\n      started_at TIMESTAMPTZ DEFAULT NOW(),\n      completed_at TIMESTAMPTZ,\n      error TEXT\n    );\n\n    -- Spans table (for tracing)\n    CREATE TABLE IF NOT EXISTS dashboard_spans (\n      id TEXT PRIMARY KEY,\n      run_id TEXT NOT NULL REFERENCES dashboard_runs(id) ON DELETE CASCADE,\n      trace_id TEXT NOT NULL,\n      parent_id TEXT,\n      name TEXT NOT NULL,\n      kind TEXT DEFAULT 'internal',\n      status TEXT DEFAULT 'unset' CHECK (status IN ('ok', 'error', 'unset')),\n      start_time BIGINT NOT NULL,\n      end_time BIGINT,\n      duration INTEGER,\n      attributes JSONB,\n      events JSONB\n    );\n\n    -- Logs table\n    CREATE TABLE IF NOT EXISTS dashboard_logs (\n      id TEXT PRIMARY KEY,\n      timestamp TIMESTAMPTZ DEFAULT NOW(),\n      level TEXT NOT NULL CHECK (level IN ('debug', 'info', 'warn', 'error')),\n      message TEXT NOT NULL,\n      source TEXT,\n      agent_id TEXT,\n      run_id TEXT,\n      metadata JSONB\n    );\n\n    -- Messages table (conversation history)\n    CREATE TABLE IF NOT EXISTS dashboard_messages (\n      id TEXT PRIMARY KEY,\n      run_id TEXT NOT NULL REFERENCES dashboard_runs(id) ON DELETE CASCADE,\n      role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system', 'tool')),\n      content TEXT NOT NULL,\n      tool_call_id TEXT,\n      created_at TIMESTAMPTZ DEFAULT NOW()\n    );\n\n    -- Config table (key-value store)\n    CREATE TABLE IF NOT EXISTS dashboard_config (\n      key TEXT PRIMARY KEY,\n      value JSONB NOT NULL,\n      updated_at TIMESTAMPTZ DEFAULT NOW()\n    );\n\n    -- Indexes\n    CREATE INDEX IF NOT EXISTS idx_dashboard_runs_agent_id ON dashboard_runs(agent_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_runs_status ON dashboard_runs(status);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_runs_started_at ON dashboard_runs(started_at DESC);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_tool_calls_run_id ON dashboard_tool_calls(run_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_spans_run_id ON dashboard_spans(run_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_spans_trace_id ON dashboard_spans(trace_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_logs_timestamp ON dashboard_logs(timestamp DESC);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_logs_level ON dashboard_logs(level);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_logs_run_id ON dashboard_logs(run_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_messages_run_id ON dashboard_messages(run_id);\n  `);\n}\n\nexport async function closePool(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAEA,IAAI,OAAoB;AAEjB,SAAS;IACd,IAAI,CAAC,MAAM;QACT,OAAO,IAAI,qMAAI,CAAC;YACd,MAAM,QAAQ,GAAG,CAAC,aAAa,IAAI;YACnC,MAAM,SAAS,QAAQ,GAAG,CAAC,aAAa,IAAI;YAC5C,MAAM,QAAQ,GAAG,CAAC,aAAa,IAAI;YACnC,UAAU,QAAQ,GAAG,CAAC,iBAAiB,IAAI;YAC3C,UAAU,QAAQ,GAAG,CAAC,WAAW,IAAI;YACrC,KAAK;YACL,mBAAmB;YACnB,yBAAyB;QAC3B;IACF;IACA,OAAO;AACT;AAEO,eAAe,MAAS,GAAW,EAAE,MAAkB;IAC5D,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,KAAK,CAAC,KAAK;IACrC,OAAO,OAAO,IAAI;AACpB;AAEO,eAAe,SAAY,GAAW,EAAE,MAAkB;IAC/D,MAAM,OAAO,MAAM,MAAS,KAAK;IACjC,OAAO,IAAI,CAAC,EAAE,IAAI;AACpB;AAEO,eAAe,QAAQ,GAAW,EAAE,MAAkB;IAC3D,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,KAAK,CAAC,KAAK;IACrC,OAAO,OAAO,QAAQ,IAAI;AAC5B;AAEO,eAAe,gBAAmB,EAAsC;IAC7E,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,OAAO;IAEjC,IAAI;QACF,MAAM,OAAO,KAAK,CAAC;QACnB,MAAM,SAAS,MAAM,GAAG;QACxB,MAAM,OAAO,KAAK,CAAC;QACnB,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,OAAO,KAAK,CAAC;QACnB,MAAM;IACR,SAAU;QACR,OAAO,OAAO;IAChB;AACF;AAEO,eAAe;IACpB,MAAM,OAAO;IAEb,MAAM,KAAK,KAAK,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyGlB,CAAC;AACH;AAEO,eAAe;IACpB,IAAI,MAAM;QACR,MAAM,KAAK,GAAG;QACd,OAAO;IACT;AACF"}},
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/lib/db/logs.ts"],"sourcesContent":["import { query, queryOne, execute } from './index';\nimport { nanoid } from 'nanoid';\nimport type { LogEntry } from '@/types';\n\ninterface LogRow {\n  id: string;\n  timestamp: Date;\n  level: 'debug' | 'info' | 'warn' | 'error';\n  message: string;\n  source: string | null;\n  agent_id: string | null;\n  run_id: string | null;\n  metadata: Record<string, unknown> | null;\n}\n\nfunction rowToLog(row: LogRow): LogEntry {\n  return {\n    id: row.id,\n    timestamp: row.timestamp.toISOString(),\n    level: row.level,\n    message: row.message,\n    source: row.source || undefined,\n    agentId: row.agent_id || undefined,\n    runId: row.run_id || undefined,\n    metadata: row.metadata || undefined,\n  };\n}\n\nexport async function getAllLogs(options?: {\n  limit?: number;\n  offset?: number;\n  level?: string;\n  source?: string;\n  runId?: string;\n  since?: Date;\n}): Promise<LogEntry[]> {\n  let sql = 'SELECT * FROM dashboard_logs WHERE 1=1';\n  const params: unknown[] = [];\n  let paramIndex = 1;\n\n  if (options?.level) {\n    sql += ` AND level = $${paramIndex++}`;\n    params.push(options.level);\n  }\n  if (options?.source) {\n    sql += ` AND source = $${paramIndex++}`;\n    params.push(options.source);\n  }\n  if (options?.runId) {\n    sql += ` AND run_id = $${paramIndex++}`;\n    params.push(options.runId);\n  }\n  if (options?.since) {\n    sql += ` AND timestamp >= $${paramIndex++}`;\n    params.push(options.since.toISOString());\n  }\n\n  sql += ' ORDER BY timestamp DESC';\n\n  if (options?.limit) {\n    sql += ` LIMIT $${paramIndex++}`;\n    params.push(options.limit);\n  }\n  if (options?.offset) {\n    sql += ` OFFSET $${paramIndex++}`;\n    params.push(options.offset);\n  }\n\n  const rows = await query<LogRow>(sql, params);\n  return rows.map(rowToLog);\n}\n\nexport async function createLog(data: {\n  level: 'debug' | 'info' | 'warn' | 'error';\n  message: string;\n  source?: string;\n  agentId?: string;\n  runId?: string;\n  metadata?: Record<string, unknown>;\n}): Promise<LogEntry> {\n  const id = `log_${nanoid(12)}`;\n  \n  await execute(\n    `INSERT INTO dashboard_logs (id, level, message, source, agent_id, run_id, metadata)\n     VALUES ($1, $2, $3, $4, $5, $6, $7)`,\n    [\n      id,\n      data.level,\n      data.message,\n      data.source || null,\n      data.agentId || null,\n      data.runId || null,\n      data.metadata ? JSON.stringify(data.metadata) : null,\n    ]\n  );\n\n  const row = await queryOne<LogRow>(\n    'SELECT * FROM dashboard_logs WHERE id = $1',\n    [id]\n  );\n  \n  return rowToLog(row!);\n}\n\nexport async function getLogCount(level?: string): Promise<number> {\n  let sql = 'SELECT COUNT(*) as count FROM dashboard_logs';\n  const params: unknown[] = [];\n  \n  if (level) {\n    sql += ' WHERE level = $1';\n    params.push(level);\n  }\n\n  const result = await queryOne<{ count: string }>(sql, params);\n  return parseInt(result?.count || '0');\n}\n\nexport async function getRecentLogs(limit = 100): Promise<LogEntry[]> {\n  return getAllLogs({ limit });\n}\n\nexport async function clearOldLogs(olderThan: Date): Promise<number> {\n  return execute(\n    'DELETE FROM dashboard_logs WHERE timestamp < $1',\n    [olderThan.toISOString()]\n  );\n}\n\nexport async function getLogStats(): Promise<{\n  total: number;\n  debug: number;\n  info: number;\n  warn: number;\n  error: number;\n}> {\n  const result = await queryOne<{\n    total: string;\n    debug: string;\n    info: string;\n    warn: string;\n    error: string;\n  }>(`\n    SELECT \n      COUNT(*) as total,\n      SUM(CASE WHEN level = 'debug' THEN 1 ELSE 0 END) as debug,\n      SUM(CASE WHEN level = 'info' THEN 1 ELSE 0 END) as info,\n      SUM(CASE WHEN level = 'warn' THEN 1 ELSE 0 END) as warn,\n      SUM(CASE WHEN level = 'error' THEN 1 ELSE 0 END) as error\n    FROM dashboard_logs\n    WHERE timestamp >= NOW() - INTERVAL '24 hours'\n  `);\n\n  return {\n    total: parseInt(result?.total || '0'),\n    debug: parseInt(result?.debug || '0'),\n    info: parseInt(result?.info || '0'),\n    warn: parseInt(result?.warn || '0'),\n    error: parseInt(result?.error || '0'),\n  };\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;;;;;;;AAcA,SAAS,SAAS,GAAW;IAC3B,OAAO;QACL,IAAI,IAAI,EAAE;QACV,WAAW,IAAI,SAAS,CAAC,WAAW;QACpC,OAAO,IAAI,KAAK;QAChB,SAAS,IAAI,OAAO;QACpB,QAAQ,IAAI,MAAM,IAAI;QACtB,SAAS,IAAI,QAAQ,IAAI;QACzB,OAAO,IAAI,MAAM,IAAI;QACrB,UAAU,IAAI,QAAQ,IAAI;IAC5B;AACF;AAEO,eAAe,WAAW,OAOhC;IACC,IAAI,MAAM;IACV,MAAM,SAAoB,EAAE;IAC5B,IAAI,aAAa;IAEjB,IAAI,SAAS,OAAO;QAClB,OAAO,CAAC,cAAc,EAAE,cAAc;QACtC,OAAO,IAAI,CAAC,QAAQ,KAAK;IAC3B;IACA,IAAI,SAAS,QAAQ;QACnB,OAAO,CAAC,eAAe,EAAE,cAAc;QACvC,OAAO,IAAI,CAAC,QAAQ,MAAM;IAC5B;IACA,IAAI,SAAS,OAAO;QAClB,OAAO,CAAC,eAAe,EAAE,cAAc;QACvC,OAAO,IAAI,CAAC,QAAQ,KAAK;IAC3B;IACA,IAAI,SAAS,OAAO;QAClB,OAAO,CAAC,mBAAmB,EAAE,cAAc;QAC3C,OAAO,IAAI,CAAC,QAAQ,KAAK,CAAC,WAAW;IACvC;IAEA,OAAO;IAEP,IAAI,SAAS,OAAO;QAClB,OAAO,CAAC,QAAQ,EAAE,cAAc;QAChC,OAAO,IAAI,CAAC,QAAQ,KAAK;IAC3B;IACA,IAAI,SAAS,QAAQ;QACnB,OAAO,CAAC,SAAS,EAAE,cAAc;QACjC,OAAO,IAAI,CAAC,QAAQ,MAAM;IAC5B;IAEA,MAAM,OAAO,MAAM,IAAA,6JAAK,EAAS,KAAK;IACtC,OAAO,KAAK,GAAG,CAAC;AAClB;AAEO,eAAe,UAAU,IAO/B;IACC,MAAM,KAAK,CAAC,IAAI,EAAE,IAAA,8MAAM,EAAC,KAAK;IAE9B,MAAM,IAAA,+JAAO,EACX,CAAC;wCACmC,CAAC,EACrC;QACE;QACA,KAAK,KAAK;QACV,KAAK,OAAO;QACZ,KAAK,MAAM,IAAI;QACf,KAAK,OAAO,IAAI;QAChB,KAAK,KAAK,IAAI;QACd,KAAK,QAAQ,GAAG,KAAK,SAAS,CAAC,KAAK,QAAQ,IAAI;KACjD;IAGH,MAAM,MAAM,MAAM,IAAA,gKAAQ,EACxB,8CACA;QAAC;KAAG;IAGN,OAAO,SAAS;AAClB;AAEO,eAAe,YAAY,KAAc;IAC9C,IAAI,MAAM;IACV,MAAM,SAAoB,EAAE;IAE5B,IAAI,OAAO;QACT,OAAO;QACP,OAAO,IAAI,CAAC;IACd;IAEA,MAAM,SAAS,MAAM,IAAA,gKAAQ,EAAoB,KAAK;IACtD,OAAO,SAAS,QAAQ,SAAS;AACnC;AAEO,eAAe,cAAc,QAAQ,GAAG;IAC7C,OAAO,WAAW;QAAE;IAAM;AAC5B;AAEO,eAAe,aAAa,SAAe;IAChD,OAAO,IAAA,+JAAO,EACZ,mDACA;QAAC,UAAU,WAAW;KAAG;AAE7B;AAEO,eAAe;IAOpB,MAAM,SAAS,MAAM,IAAA,gKAAQ,EAM1B,CAAC;;;;;;;;;EASJ,CAAC;IAED,OAAO;QACL,OAAO,SAAS,QAAQ,SAAS;QACjC,OAAO,SAAS,QAAQ,SAAS;QACjC,MAAM,SAAS,QAAQ,QAAQ;QAC/B,MAAM,SAAS,QAAQ,QAAQ;QAC/B,OAAO,SAAS,QAAQ,SAAS;IACnC;AACF"}},
    {"offset": {"line": 460, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/lib/redis.ts"],"sourcesContent":["import Redis from 'ioredis';\n\nlet redis: Redis | null = null;\nlet subscriber: Redis | null = null;\n\nexport function getRedis(): Redis {\n  if (!redis) {\n    redis = new Redis({\n      host: process.env.REDIS_HOST || 'localhost',\n      port: parseInt(process.env.REDIS_PORT || '6379'),\n      maxRetriesPerRequest: 3,\n      lazyConnect: true,\n    });\n  }\n  return redis;\n}\n\nexport function getSubscriber(): Redis {\n  if (!subscriber) {\n    subscriber = new Redis({\n      host: process.env.REDIS_HOST || 'localhost',\n      port: parseInt(process.env.REDIS_PORT || '6379'),\n      maxRetriesPerRequest: 3,\n      lazyConnect: true,\n    });\n  }\n  return subscriber;\n}\n\nexport async function publish(channel: string, message: unknown): Promise<void> {\n  const client = getRedis();\n  await client.publish(channel, JSON.stringify(message));\n}\n\nexport async function subscribe(\n  channel: string,\n  callback: (message: unknown) => void\n): Promise<() => void> {\n  const sub = getSubscriber();\n  \n  await sub.subscribe(channel);\n  \n  const handler = (ch: string, msg: string) => {\n    if (ch === channel) {\n      try {\n        callback(JSON.parse(msg));\n      } catch {\n        callback(msg);\n      }\n    }\n  };\n  \n  sub.on('message', handler);\n  \n  return () => {\n    sub.off('message', handler);\n    sub.unsubscribe(channel);\n  };\n}\n\nexport async function cache<T>(\n  key: string,\n  fn: () => Promise<T>,\n  ttlSeconds = 60\n): Promise<T> {\n  const client = getRedis();\n  \n  const cached = await client.get(key);\n  if (cached) {\n    return JSON.parse(cached) as T;\n  }\n  \n  const result = await fn();\n  await client.setex(key, ttlSeconds, JSON.stringify(result));\n  \n  return result;\n}\n\nexport async function invalidateCache(pattern: string): Promise<void> {\n  const client = getRedis();\n  const keys = await client.keys(pattern);\n  if (keys.length > 0) {\n    await client.del(...keys);\n  }\n}\n\nexport async function closeRedis(): Promise<void> {\n  if (redis) {\n    await redis.quit();\n    redis = null;\n  }\n  if (subscriber) {\n    await subscriber.quit();\n    subscriber = null;\n  }\n}\n\n// Real-time channels\nexport const CHANNELS = {\n  RUN_STARTED: 'cogitator:run:started',\n  RUN_COMPLETED: 'cogitator:run:completed',\n  RUN_FAILED: 'cogitator:run:failed',\n  LOG_ENTRY: 'cogitator:log:entry',\n  AGENT_STATUS: 'cogitator:agent:status',\n  TOOL_CALL: 'cogitator:tool:call',\n} as const;\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;AAEA,IAAI,QAAsB;AAC1B,IAAI,aAA2B;AAExB,SAAS;IACd,IAAI,CAAC,OAAO;QACV,QAAQ,IAAI,0MAAK,CAAC;YAChB,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;YAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;YACzC,sBAAsB;YACtB,aAAa;QACf;IACF;IACA,OAAO;AACT;AAEO,SAAS;IACd,IAAI,CAAC,YAAY;QACf,aAAa,IAAI,0MAAK,CAAC;YACrB,MAAM,QAAQ,GAAG,CAAC,UAAU,IAAI;YAChC,MAAM,SAAS,QAAQ,GAAG,CAAC,UAAU,IAAI;YACzC,sBAAsB;YACtB,aAAa;QACf;IACF;IACA,OAAO;AACT;AAEO,eAAe,QAAQ,OAAe,EAAE,OAAgB;IAC7D,MAAM,SAAS;IACf,MAAM,OAAO,OAAO,CAAC,SAAS,KAAK,SAAS,CAAC;AAC/C;AAEO,eAAe,UACpB,OAAe,EACf,QAAoC;IAEpC,MAAM,MAAM;IAEZ,MAAM,IAAI,SAAS,CAAC;IAEpB,MAAM,UAAU,CAAC,IAAY;QAC3B,IAAI,OAAO,SAAS;YAClB,IAAI;gBACF,SAAS,KAAK,KAAK,CAAC;YACtB,EAAE,OAAM;gBACN,SAAS;YACX;QACF;IACF;IAEA,IAAI,EAAE,CAAC,WAAW;IAElB,OAAO;QACL,IAAI,GAAG,CAAC,WAAW;QACnB,IAAI,WAAW,CAAC;IAClB;AACF;AAEO,eAAe,MACpB,GAAW,EACX,EAAoB,EACpB,aAAa,EAAE;IAEf,MAAM,SAAS;IAEf,MAAM,SAAS,MAAM,OAAO,GAAG,CAAC;IAChC,IAAI,QAAQ;QACV,OAAO,KAAK,KAAK,CAAC;IACpB;IAEA,MAAM,SAAS,MAAM;IACrB,MAAM,OAAO,KAAK,CAAC,KAAK,YAAY,KAAK,SAAS,CAAC;IAEnD,OAAO;AACT;AAEO,eAAe,gBAAgB,OAAe;IACnD,MAAM,SAAS;IACf,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC;IAC/B,IAAI,KAAK,MAAM,GAAG,GAAG;QACnB,MAAM,OAAO,GAAG,IAAI;IACtB;AACF;AAEO,eAAe;IACpB,IAAI,OAAO;QACT,MAAM,MAAM,IAAI;QAChB,QAAQ;IACV;IACA,IAAI,YAAY;QACd,MAAM,WAAW,IAAI;QACrB,aAAa;IACf;AACF;AAGO,MAAM,WAAW;IACtB,aAAa;IACb,eAAe;IACf,YAAY;IACZ,WAAW;IACX,cAAc;IACd,WAAW;AACb"}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/app/api/logs/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getAllLogs, createLog, getLogStats } from '@/lib/db/logs';\nimport { initializeSchema } from '@/lib/db';\nimport { publish, CHANNELS } from '@/lib/redis';\n\nlet initialized = false;\n\nasync function ensureInitialized() {\n  if (!initialized) {\n    try {\n      await initializeSchema();\n      initialized = true;\n    } catch (error) {\n      console.error('Failed to initialize database:', error);\n    }\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    await ensureInitialized();\n    \n    const searchParams = request.nextUrl.searchParams;\n    const level = searchParams.get('level') || undefined;\n    const source = searchParams.get('source') || undefined;\n    const runId = searchParams.get('runId') || undefined;\n    const limit = parseInt(searchParams.get('limit') || '100');\n    const offset = parseInt(searchParams.get('offset') || '0');\n    const since = searchParams.get('since');\n\n    const logs = await getAllLogs({\n      level,\n      source,\n      runId,\n      limit,\n      offset,\n      since: since ? new Date(since) : undefined,\n    });\n    \n    const stats = await getLogStats();\n\n    return NextResponse.json({\n      logs,\n      stats,\n      pagination: { limit, offset },\n    });\n  } catch (error) {\n    console.error('Failed to fetch logs:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch logs' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    await ensureInitialized();\n    const body = await request.json();\n    \n    if (!body.level || !body.message) {\n      return NextResponse.json(\n        { error: 'level and message are required' },\n        { status: 400 }\n      );\n    }\n\n    const log = await createLog({\n      level: body.level,\n      message: body.message,\n      source: body.source,\n      agentId: body.agentId,\n      runId: body.runId,\n      metadata: body.metadata,\n    });\n\n    // Publish real-time event\n    try {\n      await publish(CHANNELS.LOG_ENTRY, log);\n    } catch {\n      // Redis might not be available\n    }\n\n    return NextResponse.json(log, { status: 201 });\n  } catch (error) {\n    console.error('Failed to create log:', error);\n    return NextResponse.json(\n      { error: 'Failed to create log' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;AAEA,IAAI,cAAc;AAElB,eAAe;IACb,IAAI,CAAC,aAAa;QAChB,IAAI;YACF,MAAM,IAAA,wKAAgB;YACtB,cAAc;QAChB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,kCAAkC;QAClD;IACF;AACF;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM;QAEN,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,QAAQ,aAAa,GAAG,CAAC,YAAY;QAC3C,MAAM,SAAS,aAAa,GAAG,CAAC,aAAa;QAC7C,MAAM,QAAQ,aAAa,GAAG,CAAC,YAAY;QAC3C,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY;QACpD,MAAM,SAAS,SAAS,aAAa,GAAG,CAAC,aAAa;QACtD,MAAM,QAAQ,aAAa,GAAG,CAAC;QAE/B,MAAM,OAAO,MAAM,IAAA,iKAAU,EAAC;YAC5B;YACA;YACA;YACA;YACA;YACA,OAAO,QAAQ,IAAI,KAAK,SAAS;QACnC;QAEA,MAAM,QAAQ,MAAM,IAAA,kKAAW;QAE/B,OAAO,qPAAY,CAAC,IAAI,CAAC;YACvB;YACA;YACA,YAAY;gBAAE;gBAAO;YAAO;QAC9B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,qPAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAuB,GAChC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM;QACN,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,KAAK,OAAO,EAAE;YAChC,OAAO,qPAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAiC,GAC1C;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,MAAM,MAAM,IAAA,gKAAS,EAAC;YAC1B,OAAO,KAAK,KAAK;YACjB,SAAS,KAAK,OAAO;YACrB,QAAQ,KAAK,MAAM;YACnB,SAAS,KAAK,OAAO;YACrB,OAAO,KAAK,KAAK;YACjB,UAAU,KAAK,QAAQ;QACzB;QAEA,0BAA0B;QAC1B,IAAI;YACF,MAAM,IAAA,yJAAO,EAAC,0JAAQ,CAAC,SAAS,EAAE;QACpC,EAAE,OAAM;QACN,+BAA+B;QACjC;QAEA,OAAO,qPAAY,CAAC,IAAI,CAAC,KAAK;YAAE,QAAQ;QAAI;IAC9C,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,qPAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAuB,GAChC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}