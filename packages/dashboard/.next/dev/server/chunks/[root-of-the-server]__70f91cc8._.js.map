{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/lib/db/index.ts"],"sourcesContent":["import { Pool, PoolClient } from 'pg';\n\nlet pool: Pool | null = null;\n\nexport function getPool(): Pool {\n  if (!pool) {\n    pool = new Pool({\n      host: process.env.POSTGRES_HOST || 'localhost',\n      port: parseInt(process.env.POSTGRES_PORT || '5432'),\n      user: process.env.POSTGRES_USER || 'cogitator',\n      password: process.env.POSTGRES_PASSWORD || 'cogitator',\n      database: process.env.POSTGRES_DB || 'cogitator',\n      max: 20,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: 2000,\n    });\n  }\n  return pool;\n}\n\nexport async function query<T>(sql: string, params?: unknown[]): Promise<T[]> {\n  const pool = getPool();\n  const result = await pool.query(sql, params);\n  return result.rows as T[];\n}\n\nexport async function queryOne<T>(sql: string, params?: unknown[]): Promise<T | null> {\n  const rows = await query<T>(sql, params);\n  return rows[0] || null;\n}\n\nexport async function execute(sql: string, params?: unknown[]): Promise<number> {\n  const pool = getPool();\n  const result = await pool.query(sql, params);\n  return result.rowCount || 0;\n}\n\nexport async function withTransaction<T>(fn: (client: PoolClient) => Promise<T>): Promise<T> {\n  const pool = getPool();\n  const client = await pool.connect();\n  \n  try {\n    await client.query('BEGIN');\n    const result = await fn(client);\n    await client.query('COMMIT');\n    return result;\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}\n\nexport async function initializeSchema(): Promise<void> {\n  const pool = getPool();\n  \n  await pool.query(`\n    -- Agents table\n    CREATE TABLE IF NOT EXISTS dashboard_agents (\n      id TEXT PRIMARY KEY,\n      name TEXT NOT NULL,\n      model TEXT NOT NULL,\n      description TEXT,\n      instructions TEXT,\n      status TEXT DEFAULT 'offline' CHECK (status IN ('online', 'offline', 'busy')),\n      total_runs INTEGER DEFAULT 0,\n      total_tokens BIGINT DEFAULT 0,\n      total_cost DECIMAL(12, 6) DEFAULT 0,\n      last_run_at TIMESTAMPTZ,\n      created_at TIMESTAMPTZ DEFAULT NOW(),\n      updated_at TIMESTAMPTZ DEFAULT NOW()\n    );\n\n    -- Runs table\n    CREATE TABLE IF NOT EXISTS dashboard_runs (\n      id TEXT PRIMARY KEY,\n      agent_id TEXT NOT NULL REFERENCES dashboard_agents(id) ON DELETE CASCADE,\n      thread_id TEXT,\n      status TEXT DEFAULT 'running' CHECK (status IN ('running', 'completed', 'failed', 'cancelled')),\n      input TEXT NOT NULL,\n      output TEXT,\n      started_at TIMESTAMPTZ DEFAULT NOW(),\n      completed_at TIMESTAMPTZ,\n      duration INTEGER,\n      input_tokens INTEGER DEFAULT 0,\n      output_tokens INTEGER DEFAULT 0,\n      total_tokens INTEGER DEFAULT 0,\n      cost DECIMAL(12, 6) DEFAULT 0,\n      error TEXT\n    );\n\n    -- Tool calls table\n    CREATE TABLE IF NOT EXISTS dashboard_tool_calls (\n      id TEXT PRIMARY KEY,\n      run_id TEXT NOT NULL REFERENCES dashboard_runs(id) ON DELETE CASCADE,\n      name TEXT NOT NULL,\n      arguments JSONB,\n      result JSONB,\n      status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'success', 'error')),\n      duration INTEGER,\n      started_at TIMESTAMPTZ DEFAULT NOW(),\n      completed_at TIMESTAMPTZ,\n      error TEXT\n    );\n\n    -- Spans table (for tracing)\n    CREATE TABLE IF NOT EXISTS dashboard_spans (\n      id TEXT PRIMARY KEY,\n      run_id TEXT NOT NULL REFERENCES dashboard_runs(id) ON DELETE CASCADE,\n      trace_id TEXT NOT NULL,\n      parent_id TEXT,\n      name TEXT NOT NULL,\n      kind TEXT DEFAULT 'internal',\n      status TEXT DEFAULT 'unset' CHECK (status IN ('ok', 'error', 'unset')),\n      start_time BIGINT NOT NULL,\n      end_time BIGINT,\n      duration INTEGER,\n      attributes JSONB,\n      events JSONB\n    );\n\n    -- Logs table\n    CREATE TABLE IF NOT EXISTS dashboard_logs (\n      id TEXT PRIMARY KEY,\n      timestamp TIMESTAMPTZ DEFAULT NOW(),\n      level TEXT NOT NULL CHECK (level IN ('debug', 'info', 'warn', 'error')),\n      message TEXT NOT NULL,\n      source TEXT,\n      agent_id TEXT,\n      run_id TEXT,\n      metadata JSONB\n    );\n\n    -- Messages table (conversation history)\n    CREATE TABLE IF NOT EXISTS dashboard_messages (\n      id TEXT PRIMARY KEY,\n      run_id TEXT NOT NULL REFERENCES dashboard_runs(id) ON DELETE CASCADE,\n      role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system', 'tool')),\n      content TEXT NOT NULL,\n      tool_call_id TEXT,\n      created_at TIMESTAMPTZ DEFAULT NOW()\n    );\n\n    -- Config table (key-value store)\n    CREATE TABLE IF NOT EXISTS dashboard_config (\n      key TEXT PRIMARY KEY,\n      value JSONB NOT NULL,\n      updated_at TIMESTAMPTZ DEFAULT NOW()\n    );\n\n    -- Indexes\n    CREATE INDEX IF NOT EXISTS idx_dashboard_runs_agent_id ON dashboard_runs(agent_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_runs_status ON dashboard_runs(status);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_runs_started_at ON dashboard_runs(started_at DESC);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_tool_calls_run_id ON dashboard_tool_calls(run_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_spans_run_id ON dashboard_spans(run_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_spans_trace_id ON dashboard_spans(trace_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_logs_timestamp ON dashboard_logs(timestamp DESC);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_logs_level ON dashboard_logs(level);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_logs_run_id ON dashboard_logs(run_id);\n    CREATE INDEX IF NOT EXISTS idx_dashboard_messages_run_id ON dashboard_messages(run_id);\n  `);\n}\n\nexport async function closePool(): Promise<void> {\n  if (pool) {\n    await pool.end();\n    pool = null;\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAEA,IAAI,OAAoB;AAEjB,SAAS;IACd,IAAI,CAAC,MAAM;QACT,OAAO,IAAI,qMAAI,CAAC;YACd,MAAM,QAAQ,GAAG,CAAC,aAAa,IAAI;YACnC,MAAM,SAAS,QAAQ,GAAG,CAAC,aAAa,IAAI;YAC5C,MAAM,QAAQ,GAAG,CAAC,aAAa,IAAI;YACnC,UAAU,QAAQ,GAAG,CAAC,iBAAiB,IAAI;YAC3C,UAAU,QAAQ,GAAG,CAAC,WAAW,IAAI;YACrC,KAAK;YACL,mBAAmB;YACnB,yBAAyB;QAC3B;IACF;IACA,OAAO;AACT;AAEO,eAAe,MAAS,GAAW,EAAE,MAAkB;IAC5D,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,KAAK,CAAC,KAAK;IACrC,OAAO,OAAO,IAAI;AACpB;AAEO,eAAe,SAAY,GAAW,EAAE,MAAkB;IAC/D,MAAM,OAAO,MAAM,MAAS,KAAK;IACjC,OAAO,IAAI,CAAC,EAAE,IAAI;AACpB;AAEO,eAAe,QAAQ,GAAW,EAAE,MAAkB;IAC3D,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,KAAK,CAAC,KAAK;IACrC,OAAO,OAAO,QAAQ,IAAI;AAC5B;AAEO,eAAe,gBAAmB,EAAsC;IAC7E,MAAM,OAAO;IACb,MAAM,SAAS,MAAM,KAAK,OAAO;IAEjC,IAAI;QACF,MAAM,OAAO,KAAK,CAAC;QACnB,MAAM,SAAS,MAAM,GAAG;QACxB,MAAM,OAAO,KAAK,CAAC;QACnB,OAAO;IACT,EAAE,OAAO,OAAO;QACd,MAAM,OAAO,KAAK,CAAC;QACnB,MAAM;IACR,SAAU;QACR,OAAO,OAAO;IAChB;AACF;AAEO,eAAe;IACpB,MAAM,OAAO;IAEb,MAAM,KAAK,KAAK,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyGlB,CAAC;AACH;AAEO,eAAe;IACpB,IAAI,MAAM;QACR,MAAM,KAAK,GAAG;QACd,OAAO;IACT;AACF"}},
    {"offset": {"line": 237, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/lib/db/analytics.ts"],"sourcesContent":["import { query, queryOne } from './index';\n\nexport interface HourlyStats {\n  hour: string;\n  runs: number;\n  tokens: number;\n  cost: number;\n}\n\nexport interface ModelStats {\n  model: string;\n  runs: number;\n  tokens: number;\n  cost: number;\n}\n\nexport interface AgentStats {\n  id: string;\n  name: string;\n  model: string;\n  runs: number;\n  tokens: number;\n  cost: number;\n  avgDuration: number;\n  successRate: number;\n}\n\nexport async function getHourlyStats(hours = 24): Promise<HourlyStats[]> {\n  const rows = await query<{\n    hour: Date;\n    runs: string;\n    tokens: string;\n    cost: string;\n  }>(`\n    WITH hours AS (\n      SELECT generate_series(\n        date_trunc('hour', NOW() - INTERVAL '${hours} hours'),\n        date_trunc('hour', NOW()),\n        INTERVAL '1 hour'\n      ) AS hour\n    )\n    SELECT \n      h.hour,\n      COALESCE(COUNT(r.id), 0) as runs,\n      COALESCE(SUM(r.total_tokens), 0) as tokens,\n      COALESCE(SUM(r.cost), 0) as cost\n    FROM hours h\n    LEFT JOIN dashboard_runs r ON date_trunc('hour', r.started_at) = h.hour\n    GROUP BY h.hour\n    ORDER BY h.hour\n  `);\n\n  return rows.map(row => ({\n    hour: row.hour.toISOString(),\n    runs: parseInt(row.runs),\n    tokens: parseInt(row.tokens),\n    cost: parseFloat(row.cost),\n  }));\n}\n\nexport async function getModelStats(period: 'day' | 'week' | 'month' = 'day'): Promise<ModelStats[]> {\n  const intervals = {\n    day: \"NOW() - INTERVAL '1 day'\",\n    week: \"NOW() - INTERVAL '7 days'\",\n    month: \"NOW() - INTERVAL '30 days'\",\n  };\n\n  const rows = await query<{\n    model: string;\n    runs: string;\n    tokens: string;\n    cost: string;\n  }>(`\n    SELECT \n      a.model,\n      COUNT(r.id) as runs,\n      COALESCE(SUM(r.total_tokens), 0) as tokens,\n      COALESCE(SUM(r.cost), 0) as cost\n    FROM dashboard_runs r\n    JOIN dashboard_agents a ON r.agent_id = a.id\n    WHERE r.started_at >= ${intervals[period]}\n    GROUP BY a.model\n    ORDER BY cost DESC\n  `);\n\n  return rows.map(row => ({\n    model: row.model,\n    runs: parseInt(row.runs),\n    tokens: parseInt(row.tokens),\n    cost: parseFloat(row.cost),\n  }));\n}\n\nexport async function getTopAgents(limit = 10, period: 'day' | 'week' | 'month' = 'week'): Promise<AgentStats[]> {\n  const intervals = {\n    day: \"NOW() - INTERVAL '1 day'\",\n    week: \"NOW() - INTERVAL '7 days'\",\n    month: \"NOW() - INTERVAL '30 days'\",\n  };\n\n  const rows = await query<{\n    id: string;\n    name: string;\n    model: string;\n    runs: string;\n    tokens: string;\n    cost: string;\n    avg_duration: string;\n    success_rate: string;\n  }>(`\n    SELECT \n      a.id,\n      a.name,\n      a.model,\n      COUNT(r.id) as runs,\n      COALESCE(SUM(r.total_tokens), 0) as tokens,\n      COALESCE(SUM(r.cost), 0) as cost,\n      COALESCE(AVG(r.duration), 0) as avg_duration,\n      COALESCE(\n        SUM(CASE WHEN r.status = 'completed' THEN 1 ELSE 0 END)::float / NULLIF(COUNT(r.id), 0) * 100,\n        0\n      ) as success_rate\n    FROM dashboard_agents a\n    LEFT JOIN dashboard_runs r ON r.agent_id = a.id AND r.started_at >= ${intervals[period]}\n    GROUP BY a.id, a.name, a.model\n    ORDER BY runs DESC\n    LIMIT $1\n  `, [limit]);\n\n  return rows.map(row => ({\n    id: row.id,\n    name: row.name,\n    model: row.model,\n    runs: parseInt(row.runs),\n    tokens: parseInt(row.tokens),\n    cost: parseFloat(row.cost),\n    avgDuration: parseFloat(row.avg_duration),\n    successRate: parseFloat(row.success_rate),\n  }));\n}\n\nexport async function getDashboardStats(): Promise<{\n  totalRuns: number;\n  activeAgents: number;\n  totalTokens: number;\n  totalCost: number;\n  runningRuns: number;\n  avgDuration: number;\n}> {\n  const result = await queryOne<{\n    total_runs: string;\n    active_agents: string;\n    total_tokens: string;\n    total_cost: string;\n    running_runs: string;\n    avg_duration: string;\n  }>(`\n    SELECT\n      (SELECT COUNT(*) FROM dashboard_runs WHERE started_at >= NOW() - INTERVAL '24 hours') as total_runs,\n      (SELECT COUNT(*) FROM dashboard_agents WHERE status != 'offline') as active_agents,\n      (SELECT COALESCE(SUM(total_tokens), 0) FROM dashboard_runs WHERE started_at >= NOW() - INTERVAL '24 hours') as total_tokens,\n      (SELECT COALESCE(SUM(cost), 0) FROM dashboard_runs WHERE started_at >= NOW() - INTERVAL '24 hours') as total_cost,\n      (SELECT COUNT(*) FROM dashboard_runs WHERE status = 'running') as running_runs,\n      (SELECT COALESCE(AVG(duration), 0) FROM dashboard_runs WHERE started_at >= NOW() - INTERVAL '24 hours' AND duration IS NOT NULL) as avg_duration\n  `);\n\n  return {\n    totalRuns: parseInt(result?.total_runs || '0'),\n    activeAgents: parseInt(result?.active_agents || '0'),\n    totalTokens: parseInt(result?.total_tokens || '0'),\n    totalCost: parseFloat(result?.total_cost || '0'),\n    runningRuns: parseInt(result?.running_runs || '0'),\n    avgDuration: parseFloat(result?.avg_duration || '0'),\n  };\n}\n\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;;AA2BO,eAAe,eAAe,QAAQ,EAAE;IAC7C,MAAM,OAAO,MAAM,IAAA,6JAAK,EAKrB,CAAC;;;6CAGuC,EAAE,MAAM;;;;;;;;;;;;;;EAcnD,CAAC;IAED,OAAO,KAAK,GAAG,CAAC,CAAA,MAAO,CAAC;YACtB,MAAM,IAAI,IAAI,CAAC,WAAW;YAC1B,MAAM,SAAS,IAAI,IAAI;YACvB,QAAQ,SAAS,IAAI,MAAM;YAC3B,MAAM,WAAW,IAAI,IAAI;QAC3B,CAAC;AACH;AAEO,eAAe,cAAc,SAAmC,KAAK;IAC1E,MAAM,YAAY;QAChB,KAAK;QACL,MAAM;QACN,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,IAAA,6JAAK,EAKrB,CAAC;;;;;;;;0BAQoB,EAAE,SAAS,CAAC,OAAO,CAAC;;;EAG5C,CAAC;IAED,OAAO,KAAK,GAAG,CAAC,CAAA,MAAO,CAAC;YACtB,OAAO,IAAI,KAAK;YAChB,MAAM,SAAS,IAAI,IAAI;YACvB,QAAQ,SAAS,IAAI,MAAM;YAC3B,MAAM,WAAW,IAAI,IAAI;QAC3B,CAAC;AACH;AAEO,eAAe,aAAa,QAAQ,EAAE,EAAE,SAAmC,MAAM;IACtF,MAAM,YAAY;QAChB,KAAK;QACL,MAAM;QACN,OAAO;IACT;IAEA,MAAM,OAAO,MAAM,IAAA,6JAAK,EASrB,CAAC;;;;;;;;;;;;;;wEAckE,EAAE,SAAS,CAAC,OAAO,CAAC;;;;EAI1F,CAAC,EAAE;QAAC;KAAM;IAEV,OAAO,KAAK,GAAG,CAAC,CAAA,MAAO,CAAC;YACtB,IAAI,IAAI,EAAE;YACV,MAAM,IAAI,IAAI;YACd,OAAO,IAAI,KAAK;YAChB,MAAM,SAAS,IAAI,IAAI;YACvB,QAAQ,SAAS,IAAI,MAAM;YAC3B,MAAM,WAAW,IAAI,IAAI;YACzB,aAAa,WAAW,IAAI,YAAY;YACxC,aAAa,WAAW,IAAI,YAAY;QAC1C,CAAC;AACH;AAEO,eAAe;IAQpB,MAAM,SAAS,MAAM,IAAA,gKAAQ,EAO1B,CAAC;;;;;;;;EAQJ,CAAC;IAED,OAAO;QACL,WAAW,SAAS,QAAQ,cAAc;QAC1C,cAAc,SAAS,QAAQ,iBAAiB;QAChD,aAAa,SAAS,QAAQ,gBAAgB;QAC9C,WAAW,WAAW,QAAQ,cAAc;QAC5C,aAAa,SAAS,QAAQ,gBAAgB;QAC9C,aAAa,WAAW,QAAQ,gBAAgB;IAClD;AACF"}},
    {"offset": {"line": 368, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Projects/Cogitator/packages/dashboard/src/app/api/analytics/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getHourlyStats, getModelStats, getTopAgents, getDashboardStats } from '@/lib/db/analytics';\nimport { initializeSchema } from '@/lib/db';\n\nlet initialized = false;\n\nasync function ensureInitialized() {\n  if (!initialized) {\n    try {\n      await initializeSchema();\n      initialized = true;\n    } catch (error) {\n      console.error('Failed to initialize database:', error);\n    }\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    await ensureInitialized();\n    \n    const searchParams = request.nextUrl.searchParams;\n    const period = (searchParams.get('period') || 'day') as 'day' | 'week' | 'month';\n    const hours = parseInt(searchParams.get('hours') || '24');\n\n    const [hourlyStats, modelStats, topAgents, dashboardStats] = await Promise.all([\n      getHourlyStats(hours),\n      getModelStats(period),\n      getTopAgents(10, period),\n      getDashboardStats(),\n    ]);\n\n    return NextResponse.json({\n      hourly: hourlyStats,\n      models: modelStats,\n      topAgents,\n      dashboard: dashboardStats,\n      period,\n    });\n  } catch (error) {\n    console.error('Failed to fetch analytics:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch analytics' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;AAEA,IAAI,cAAc;AAElB,eAAe;IACb,IAAI,CAAC,aAAa;QAChB,IAAI;YACF,MAAM,IAAA,wKAAgB;YACtB,cAAc;QAChB,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,kCAAkC;QAClD;IACF;AACF;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM;QAEN,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,SAAU,aAAa,GAAG,CAAC,aAAa;QAC9C,MAAM,QAAQ,SAAS,aAAa,GAAG,CAAC,YAAY;QAEpD,MAAM,CAAC,aAAa,YAAY,WAAW,eAAe,GAAG,MAAM,QAAQ,GAAG,CAAC;YAC7E,IAAA,0KAAc,EAAC;YACf,IAAA,yKAAa,EAAC;YACd,IAAA,wKAAY,EAAC,IAAI;YACjB,IAAA,6KAAiB;SAClB;QAED,OAAO,qPAAY,CAAC,IAAI,CAAC;YACvB,QAAQ;YACR,QAAQ;YACR;YACA,WAAW;YACX;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO,qPAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4B,GACrC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}